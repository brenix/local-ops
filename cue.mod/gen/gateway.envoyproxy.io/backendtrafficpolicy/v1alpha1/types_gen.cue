// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f /tmp/crds.yaml

package v1alpha1

import (
	"strings"
	"list"
)

// BackendTrafficPolicy allows the user to configure the behavior
// of the connection
// between the Envoy Proxy listener and the backend service.
#BackendTrafficPolicy: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "gateway.envoyproxy.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "BackendTrafficPolicy"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// spec defines the desired state of BackendTrafficPolicy.
	spec!: #BackendTrafficPolicySpec
}

// spec defines the desired state of BackendTrafficPolicy.
#BackendTrafficPolicySpec: {
	// Circuit Breaker settings for the upstream connections and
	// requests.
	// If not set, circuit breakers will be enabled with the default
	// thresholds
	circuitBreaker?: {
		// The maximum number of connections that Envoy will establish to
		// the referenced backend defined within a xRoute rule.
		maxConnections?: int & <=4294967295 & >=0 | *1024

		// The maximum number of parallel requests that Envoy will make to
		// the referenced backend defined within a xRoute rule.
		maxParallelRequests?: int & <=4294967295 & >=0 | *1024

		// The maximum number of parallel retries that Envoy will make to
		// the referenced backend defined within a xRoute rule.
		maxParallelRetries?: int & <=4294967295 & >=0 | *1024

		// The maximum number of pending requests that Envoy will queue to
		// the referenced backend defined within a xRoute rule.
		maxPendingRequests?: int & <=4294967295 & >=0 | *1024

		// The maximum number of requests that Envoy will make over a
		// single connection to the referenced backend defined within a
		// xRoute rule.
		// Default: unlimited.
		maxRequestsPerConnection?: uint32
		perEndpoint?: {
			// MaxConnections configures the maximum number of connections
			// that Envoy will establish per-endpoint to the referenced
			// backend defined within a xRoute rule.
			maxConnections?: int & <=4294967295 & >=0 | *1024
		}
	}

	// The compression config for the http streams.
	compression?: [...{
		// The configuration for Brotli compressor.
		brotli?: {}

		// The configuration for GZIP compressor.
		gzip?: {}

		// CompressorType defines the compressor type to use for
		// compression.
		type: "Gzip" | "Brotli"
	}]

	// Connection includes backend connection settings.
	connection?: {
		// BufferLimit Soft limit on size of the cluster’s connections
		// read and write buffers.
		// BufferLimit applies to connection streaming (maybe
		// non-streaming) channel between processes, it's in user space.
		// If unspecified, an implementation defined default is applied
		// (32768 bytes).
		// For example, 20Mi, 1Gi, 256Ki etc.
		// Note: that when the suffix is not provided, the value is
		// interpreted as bytes.
		bufferLimit?: (null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}) & (null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}) & (int | string)

		// SocketBufferLimit provides configuration for the maximum buffer
		// size in bytes for each socket
		// to backend.
		// SocketBufferLimit applies to socket streaming channel between
		// TCP/IP stacks, it's in kernel space.
		// For example, 20Mi, 1Gi, 256Ki etc.
		// Note that when the suffix is not provided, the value is
		// interpreted as bytes.
		socketBufferLimit?: (null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}) & (null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}) & (int | string)
	}

	// DNS includes dns resolution settings.
	dns?: {
		// DNSRefreshRate specifies the rate at which DNS records should
		// be refreshed.
		// Defaults to 30 seconds.
		dnsRefreshRate?: string

		// LookupFamily determines how Envoy would resolve DNS for Routes
		// where the backend is specified as a fully qualified domain
		// name (FQDN).
		// If set, this configuration overrides other defaults.
		lookupFamily?: "IPv4" | "IPv6" | "IPv4Preferred" | "IPv6Preferred" | "IPv4AndIPv6"

		// RespectDNSTTL indicates whether the DNS Time-To-Live (TTL)
		// should be respected.
		// If the value is set to true, the DNS refresh rate will be set
		// to the resource record’s TTL.
		// Defaults to true.
		respectDnsTtl?: bool
	}

	// FaultInjection defines the fault injection policy to be
	// applied. This configuration can be used to
	// inject delays and abort requests to mimic failure scenarios
	// such as service failures and overloads
	faultInjection?: {
		// If specified, the request will be aborted if it meets the
		// configuration criteria.
		abort?: {
			// GrpcStatus specifies the GRPC status code to be returned
			grpcStatus?: int

			// StatusCode specifies the HTTP status code to be returned
			httpStatus?: uint & >=200 & <=600

			// Percentage specifies the percentage of requests to be aborted.
			// Default 100%, if set 0, no requests will be aborted. Accuracy
			// to 0.0001%.
			percentage?: number | *100
		}

		// If specified, a delay will be injected into the request.
		delay?: {
			// FixedDelay specifies the fixed delay duration
			fixedDelay: string

			// Percentage specifies the percentage of requests to be delayed.
			// Default 100%, if set 0, no requests will be delayed. Accuracy
			// to 0.0001%.
			percentage?: number | *100
		}
	}

	// HealthCheck allows gateway to perform active health checking on
	// backends.
	healthCheck?: {
		// Active health check configuration
		active?: {
			grpc?: {
				// Service to send in the health check request.
				// If this is not specified, then the health check request applies
				// to the entire
				// server and not to a specific service.
				service?: string
			}

			// HealthyThreshold defines the number of healthy health checks
			// required before a backend host is marked healthy.
			healthyThreshold?: int & >=1 | *1

			// HTTP defines the configuration of http health checker.
			// It's required while the health checker type is HTTP.
			http?: {
				// ExpectedResponse defines a list of HTTP expected responses to
				// match.
				expectedResponse?: {
					// Binary payload base64 encoded.
					binary?: string

					// Text payload in plain text.
					text?: string

					// Type defines the type of the payload.
					type: ("Text" | "Binary") & ("Text" | "Binary")
				}

				// ExpectedStatuses defines a list of HTTP response statuses
				// considered healthy.
				// Defaults to 200 only
				expectedStatuses?: [...int & <600 & >=100]

				// Hostname defines the HTTP host that will be requested during
				// health checking.
				// Default: HTTPRoute or GRPCRoute hostname.
				hostname?: strings.MaxRunes(253) & strings.MinRunes(1) & {
					=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
				}

				// Method defines the HTTP method used for health checking.
				// Defaults to GET
				method?: string

				// Path defines the HTTP path that will be requested during health
				// checking.
				path: strings.MaxRunes(1024) & strings.MinRunes(1)
			}

			// Interval defines the time between active health checks.
			interval?: string | *"3s"

			// TCP defines the configuration of tcp health checker.
			// It's required while the health checker type is TCP.
			tcp?: {
				// Receive defines the expected response payload.
				receive?: {
					// Binary payload base64 encoded.
					binary?: string

					// Text payload in plain text.
					text?: string

					// Type defines the type of the payload.
					type: ("Text" | "Binary") & ("Text" | "Binary")
				}

				// Send defines the request payload.
				send?: {
					// Binary payload base64 encoded.
					binary?: string

					// Text payload in plain text.
					text?: string

					// Type defines the type of the payload.
					type: ("Text" | "Binary") & ("Text" | "Binary")
				}
			}

			// Timeout defines the time to wait for a health check response.
			timeout?: string | *"1s"

			// Type defines the type of health checker.
			type: ("HTTP" | "TCP" | "GRPC") & ("HTTP" | "TCP" | "GRPC")

			// UnhealthyThreshold defines the number of unhealthy health
			// checks required before a backend host is marked unhealthy.
			unhealthyThreshold?: int & >=1 | *3
		}

		// When number of unhealthy endpoints for a backend reaches this
		// threshold
		// Envoy will disregard health status and balance across all
		// endpoints.
		// It's designed to prevent a situation in which host failures
		// cascade throughout the cluster
		// as load increases. If not set, the default value is 50%. To
		// disable panic mode, set value to `0`.
		panicThreshold?: uint & <=100

		// Passive passive check configuration
		passive?: {
			// BaseEjectionTime defines the base duration for which a host
			// will be ejected on consecutive failures.
			baseEjectionTime?: string | *"30s"

			// Consecutive5xxErrors sets the number of consecutive 5xx errors
			// triggering ejection.
			consecutive5XxErrors?: int | *5

			// ConsecutiveGatewayErrors sets the number of consecutive gateway
			// errors triggering ejection.
			consecutiveGatewayErrors?: int | *0

			// ConsecutiveLocalOriginFailures sets the number of consecutive
			// local origin failures triggering ejection.
			// Parameter takes effect only when
			// split_external_local_origin_errors is set to true.
			consecutiveLocalOriginFailures?: int | *5

			// Interval defines the time between passive health checks.
			interval?: string | *"3s"

			// MaxEjectionPercent sets the maximum percentage of hosts in a
			// cluster that can be ejected.
			maxEjectionPercent?: int | *10

			// SplitExternalLocalOriginErrors enables splitting of errors
			// between external and local origin.
			splitExternalLocalOriginErrors?: bool | *false
		}
	}

	// HTTP2 provides HTTP/2 configuration for backend connections.
	http2?: {
		// InitialConnectionWindowSize sets the initial window size for
		// HTTP/2 connections.
		// If not set, the default value is 1 MiB.
		initialConnectionWindowSize?: (null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}) & (null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}) & (int | string)

		// InitialStreamWindowSize sets the initial window size for HTTP/2
		// streams.
		// If not set, the default value is 64 KiB(64*1024).
		initialStreamWindowSize?: (null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}) & (null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}) & (int | string)

		// MaxConcurrentStreams sets the maximum number of concurrent
		// streams allowed per connection.
		// If not set, the default value is 100.
		maxConcurrentStreams?: int32 & >=1

		// OnInvalidMessage determines if Envoy will terminate the
		// connection or just the offending stream in the event of HTTP
		// messaging error
		// It's recommended for L2 Envoy deployments to set this value to
		// TerminateStream.
		// https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
		// Default: TerminateConnection
		onInvalidMessage?: string
	}

	// HTTPUpgrade defines the configuration for HTTP protocol
	// upgrades.
	// If not specified, the default upgrade configuration(websocket)
	// will be used.
	httpUpgrade?: [...{
		// Type is the case-insensitive type of protocol upgrade.
		// e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
		type: string
	}]

	// LoadBalancer policy to apply when routing traffic from the
	// gateway to
	// the backend endpoints. Defaults to `LeastRequest`.
	loadBalancer?: {
		// ConsistentHash defines the configuration when the load balancer
		// type is
		// set to ConsistentHash
		consistentHash?: {
			// Cookie configures the cookie hash policy when the consistent
			// hash type is set to Cookie.
			cookie?: {
				// Additional Attributes to set for the generated cookie.
				attributes?: {
					[string]: string
				}

				// Name of the cookie to hash.
				// If this cookie does not exist in the request, Envoy will
				// generate a cookie and set
				// the TTL on the response back to the client based on Layer 4
				// attributes of the backend endpoint, to ensure that these future
				// requests
				// go to the same backend endpoint. Make sure to set the TTL field
				// for this case.
				name: string

				// TTL of the generated cookie if the cookie is not present. This
				// value sets the
				// Max-Age attribute value.
				ttl?: string
			}
			header?: {
				// Name of the header to hash.
				name: string
			}

			// The table size for consistent hashing, must be prime number
			// limited to 5000011.
			tableSize?: int & <=5000011 & >=2 | *65537

			// ConsistentHashType defines the type of input to hash on. Valid
			// Type values are
			// "SourceIP",
			// "Header",
			// "Cookie".
			type: "SourceIP" | "Header" | "Cookie"
		}
		slowStart?: {
			// Window defines the duration of the warm up period for newly
			// added host.
			// During slow start window, traffic sent to the newly added hosts
			// will gradually increase.
			// Currently only supports linear growth of traffic. For
			// additional details,
			// see
			// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
			window: string
		}

		// Type decides the type of Load Balancer policy.
		// Valid LoadBalancerType values are
		// "ConsistentHash",
		// "LeastRequest",
		// "Random",
		// "RoundRobin".
		type: "ConsistentHash" | "LeastRequest" | "Random" | "RoundRobin"
	}

	// MergeType determines how this configuration is merged with
	// existing BackendTrafficPolicy
	// configurations targeting a parent resource. When set, this
	// configuration will be merged
	// into a parent BackendTrafficPolicy (i.e. the one targeting a
	// Gateway or Listener).
	// This field cannot be set when targeting a parent resource
	// (Gateway).
	// If unset, no merging occurs, and only the most specific
	// configuration takes effect.
	mergeType?: string
	proxyProtocol?: {
		// Version of ProxyProtol
		// Valid ProxyProtocolVersion values are
		// "V1"
		// "V2"
		version: "V1" | "V2"
	}

	// RateLimit allows the user to limit the number of incoming
	// requests
	// to a predefined value based on attributes within the traffic
	// flow.
	rateLimit?: {
		global?: {
			// Rules are a list of RateLimit selectors and limits. Each rule
			// and its
			// associated limit is applied in a mutually exclusive way. If a
			// request
			// matches multiple rules, each of their associated limits get
			// applied, so a
			// single request might increase the rate limit counters for
			// multiple rules
			// if selected. The rate limit service will return a logical OR of
			// the individual
			// rate limit decisions of all matching rules. For example, if a
			// request
			// matches two rules, one rate limited and one not, the final
			// decision will be
			// to rate limit the request.
			rules: list.MaxItems(64) & [...{
				// ClientSelectors holds the list of select conditions to select
				// specific clients using attributes from the traffic flow.
				// All individual select conditions must hold True for this rule
				// and its limit to be applied.
				//
				// If no client selectors are specified, the rule applies to all
				// traffic of
				// the targeted Route.
				//
				// If the policy targets a Gateway, the rule applies to each Route
				// of the Gateway.
				// Please note that each Route has its own rate limit counters.
				// For example,
				// if a Gateway has two Routes, and the policy has a rule with
				// limit 10rps,
				// each Route will have its own 10rps limit.
				clientSelectors?: list.MaxItems(8) & [...{
					// Headers is a list of request headers to match. Multiple header
					// values are ANDed together,
					// meaning, a request MUST match all the specified headers.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					headers?: list.MaxItems(16) & [...{
						// Invert specifies whether the value match result will be
						// inverted.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						invert?: bool | *false

						// Name of the HTTP header.
						// The header name is case-insensitive unless PreserveHeaderCase
						// is set to true.
						// For example, "Foo" and "foo" are considered the same header.
						name: strings.MaxRunes(256) & strings.MinRunes(1)

						// Type specifies how to match against the value of the header.
						type?: "Exact" | "RegularExpression" | "Distinct" | *"Exact"

						// Value within the HTTP header.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						value?: strings.MaxRunes(1024)
					}]

					// SourceCIDR is the client IP Address range to match on.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					sourceCIDR?: {
						type?: "Exact" | "Distinct" | *"Exact"

						// Value is the IP CIDR that represents the range of Source IP
						// Addresses of the client.
						// These could also be the intermediate addresses through which
						// the request has flown through and is part of the
						// `X-Forwarded-For` header.
						// For example, `192.168.0.1/32`, `192.168.0.0/24`,
						// `001:db8::/64`.
						value: strings.MaxRunes(256) & strings.MinRunes(1)
					}
				}]

				// Cost specifies the cost of requests and responses for the rule.
				//
				// This is optional and if not specified, the default behavior is
				// to reduce the rate limit counters by 1 on
				// the request path and do not reduce the rate limit counters on
				// the response path.
				cost?: {
					// Request specifies the number to reduce the rate limit counters
					// on the request path. If this is not specified, the default
					// behavior
					// is to reduce the rate limit counters by 1.
					//
					// When Envoy receives a request that matches the rule, it tries
					// to reduce the
					// rate limit counters by the specified number. If the counter
					// doesn't have
					// enough capacity, the request is rate limited.
					request?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key: string

							// Namespace is the namespace of the dynamic metadata.
							namespace: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int
					}

					// Response specifies the number to reduce the rate limit counters
					// after the response is sent back to the client or the request
					// stream is closed.
					//
					// The cost is used to reduce the rate limit counters for the
					// matching requests.
					// Since the reduction happens after the request stream is
					// complete, the rate limit
					// won't be enforced for the current request, but for the
					// subsequent matching requests.
					//
					// This is optional and if not specified, the rate limit counters
					// are not reduced
					// on the response path.
					//
					// Currently, this is only supported for HTTP Global Rate Limits.
					response?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key: string

							// Namespace is the namespace of the dynamic metadata.
							namespace: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int
					}
				}

				// Limit holds the rate limit values.
				// This limit is applied for traffic flows when the selectors
				// compute to True, causing the request to be counted towards the
				// limit.
				// The limit is enforced and the request is ratelimited, i.e. a
				// response with
				// 429 HTTP status code is sent back to the client when
				// the selected requests have reached the limit.
				limit: {
					requests: int

					// RateLimitUnit specifies the intervals for setting rate limits.
					// Valid RateLimitUnit values are "Second", "Minute", "Hour", and
					// "Day".
					unit: "Second" | "Minute" | "Hour" | "Day"
				}

				// Shared determines whether this rate limit rule applies across
				// all the policy targets.
				// If set to true, the rule is treated as a common bucket and is
				// shared across all policy targets (xRoutes).
				// Default: false.
				shared?: bool
			}]
		}
		local?: {
			// Rules are a list of RateLimit selectors and limits. If a
			// request matches
			// multiple rules, the strictest limit is applied. For example, if
			// a request
			// matches two rules, one with 10rps and one with 20rps, the final
			// limit will
			// be based on the rule with 10rps.
			rules?: list.MaxItems(16) & [...{
				// ClientSelectors holds the list of select conditions to select
				// specific clients using attributes from the traffic flow.
				// All individual select conditions must hold True for this rule
				// and its limit to be applied.
				//
				// If no client selectors are specified, the rule applies to all
				// traffic of
				// the targeted Route.
				//
				// If the policy targets a Gateway, the rule applies to each Route
				// of the Gateway.
				// Please note that each Route has its own rate limit counters.
				// For example,
				// if a Gateway has two Routes, and the policy has a rule with
				// limit 10rps,
				// each Route will have its own 10rps limit.
				clientSelectors?: list.MaxItems(8) & [...{
					// Headers is a list of request headers to match. Multiple header
					// values are ANDed together,
					// meaning, a request MUST match all the specified headers.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					headers?: list.MaxItems(16) & [...{
						// Invert specifies whether the value match result will be
						// inverted.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						invert?: bool | *false

						// Name of the HTTP header.
						// The header name is case-insensitive unless PreserveHeaderCase
						// is set to true.
						// For example, "Foo" and "foo" are considered the same header.
						name: strings.MaxRunes(256) & strings.MinRunes(1)

						// Type specifies how to match against the value of the header.
						type?: "Exact" | "RegularExpression" | "Distinct" | *"Exact"

						// Value within the HTTP header.
						// Do not set this field when Type="Distinct", implying matching
						// on any/all unique
						// values within the header.
						value?: strings.MaxRunes(1024)
					}]

					// SourceCIDR is the client IP Address range to match on.
					// At least one of headers or sourceCIDR condition must be
					// specified.
					sourceCIDR?: {
						type?: "Exact" | "Distinct" | *"Exact"

						// Value is the IP CIDR that represents the range of Source IP
						// Addresses of the client.
						// These could also be the intermediate addresses through which
						// the request has flown through and is part of the
						// `X-Forwarded-For` header.
						// For example, `192.168.0.1/32`, `192.168.0.0/24`,
						// `001:db8::/64`.
						value: strings.MaxRunes(256) & strings.MinRunes(1)
					}
				}]

				// Cost specifies the cost of requests and responses for the rule.
				//
				// This is optional and if not specified, the default behavior is
				// to reduce the rate limit counters by 1 on
				// the request path and do not reduce the rate limit counters on
				// the response path.
				cost?: {
					// Request specifies the number to reduce the rate limit counters
					// on the request path. If this is not specified, the default
					// behavior
					// is to reduce the rate limit counters by 1.
					//
					// When Envoy receives a request that matches the rule, it tries
					// to reduce the
					// rate limit counters by the specified number. If the counter
					// doesn't have
					// enough capacity, the request is rate limited.
					request?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key: string

							// Namespace is the namespace of the dynamic metadata.
							namespace: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int
					}

					// Response specifies the number to reduce the rate limit counters
					// after the response is sent back to the client or the request
					// stream is closed.
					//
					// The cost is used to reduce the rate limit counters for the
					// matching requests.
					// Since the reduction happens after the request stream is
					// complete, the rate limit
					// won't be enforced for the current request, but for the
					// subsequent matching requests.
					//
					// This is optional and if not specified, the rate limit counters
					// are not reduced
					// on the response path.
					//
					// Currently, this is only supported for HTTP Global Rate Limits.
					response?: {
						// From specifies where to get the rate limit cost. Currently,
						// only "Number" and "Metadata" are supported.
						from: "Number" | "Metadata"

						// Metadata specifies the per-request metadata to retrieve the
						// usage number from.
						metadata?: {
							// Key is the key to retrieve the usage number from the filter
							// metadata.
							key: string

							// Namespace is the namespace of the dynamic metadata.
							namespace: string
						}

						// Number specifies the fixed usage number to reduce the rate
						// limit counters.
						// Using zero can be used to only check the rate limit counters
						// without reducing them.
						number?: int
					}
				}

				// Limit holds the rate limit values.
				// This limit is applied for traffic flows when the selectors
				// compute to True, causing the request to be counted towards the
				// limit.
				// The limit is enforced and the request is ratelimited, i.e. a
				// response with
				// 429 HTTP status code is sent back to the client when
				// the selected requests have reached the limit.
				limit: {
					requests: int

					// RateLimitUnit specifies the intervals for setting rate limits.
					// Valid RateLimitUnit values are "Second", "Minute", "Hour", and
					// "Day".
					unit: "Second" | "Minute" | "Hour" | "Day"
				}

				// Shared determines whether this rate limit rule applies across
				// all the policy targets.
				// If set to true, the rule is treated as a common bucket and is
				// shared across all policy targets (xRoutes).
				// Default: false.
				shared?: bool
			}]
		}

		// Type decides the scope for the RateLimits.
		// Valid RateLimitType values are "Global" or "Local".
		type: "Global" | "Local"
	}
	requestBuffer?: {
		// Limit specifies the maximum allowed size in bytes for each
		// incoming request buffer.
		// If exceeded, the request will be rejected with HTTP 413 Content
		// Too Large.
		//
		// Accepts values in resource.Quantity format (e.g., "10Mi",
		// "500Ki").
		limit?: (null | bool | number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$" | [...] | {}) & (null | bool | number | =~"^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$" | [...] | {}) & (int | string)
	}

	// ResponseOverride defines the configuration to override specific
	// responses with a custom one.
	// If multiple configurations are specified, the first one to
	// match wins.
	responseOverride?: [...{
		match: {
			// Status code to match on. The match evaluates to true if any of
			// the matches are successful.
			statusCodes: list.MaxItems(50) & [...{
				// Range contains the range of status codes.
				range?: {
					// End of the range, including the end value.
					end: int

					// Start of the range, including the start value.
					start: int
				}

				// Type is the type of value.
				// Valid values are Value and Range, default is Value.
				type: ("Value" | "Range") & ("Value" | "Range") | *"Value"

				// Value contains the value of the status code.
				value?: int
			}] & [_, ...]
		}

		// Redirect configuration
		redirect?: {
			// Hostname is the hostname to be used in the value of the
			// `Location`
			// header in the response.
			// When empty, the hostname in the `Host` header of the request is
			// used.
			hostname?: strings.MaxRunes(253) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}

			// Path defines parameters used to modify the path of the incoming
			// request.
			// The modified path is then used to construct the `Location`
			// header. When
			// empty, the request path is used as-is.
			// Only ReplaceFullPath path modifier is supported currently.
			path?: {
				// ReplaceFullPath specifies the value with which to replace the
				// full path
				// of a request during a rewrite or redirect.
				replaceFullPath?: strings.MaxRunes(1024)

				// ReplacePrefixMatch specifies the value with which to replace
				// the prefix
				// match of a request during a rewrite or redirect. For example, a
				// request
				// to "/foo/bar" with a prefix match of "/foo" and a
				// ReplacePrefixMatch
				// of "/xyz" would be modified to "/xyz/bar".
				//
				// Note that this matches the behavior of the PathPrefix match
				// type. This
				// matches full path elements. A path element refers to the list
				// of labels
				// in the path split by the `/` separator. When specified, a
				// trailing `/` is
				// ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def`
				// would all
				// match the prefix `/abc`, but the path `/abcd` would not.
				//
				// ReplacePrefixMatch is only compatible with a `PathPrefix`
				// HTTPRouteMatch.
				// Using any other HTTPRouteMatch type on the same HTTPRouteRule
				// will result in
				// the implementation setting the Accepted Condition for the Route
				// to `status: False`.
				//
				// Request Path | Prefix Match | Replace Prefix | Modified Path
				replacePrefixMatch?: strings.MaxRunes(1024)

				// Type defines the type of path modifier. Additional types may be
				// added in a future release of the API.
				//
				// Note that values may be added to this enum, implementations
				// must ensure that unknown values will not cause a crash.
				//
				// Unknown values here must result in the implementation setting
				// the
				// Accepted Condition for the Route to `status: False`, with a
				// Reason of `UnsupportedValue`.
				type: "ReplaceFullPath" | "ReplacePrefixMatch"
			}

			// Port is the port to be used in the value of the `Location`
			// header in the response.
			//
			// If redirect scheme is not-empty, the well-known port associated
			// with the redirect scheme will be used.
			// Specifically "http" to port 80 and "https" to port 443. If the
			// redirect scheme does not have a
			// well-known port or redirect scheme is empty, the listener port
			// of the Gateway will be used.
			//
			// Port will not be added in the 'Location' header if scheme is
			// HTTP and port is 80
			// or scheme is HTTPS and port is 443.
			port?: uint16 & >=1

			// Scheme is the scheme to be used in the value of the `Location`
			// header in
			// the response. When empty, the scheme of the request is used.
			scheme?: "http" | "https"

			// StatusCode is the HTTP status code to be used in response.
			statusCode?: (301 | 302) & int | *302
		}

		// Response configuration.
		response?: {
			// Body of the Custom Response
			body?: {
				// Inline contains the value as an inline string.
				inline?: string

				// Type is the type of method to use to read the body value.
				// Valid values are Inline and ValueRef, default is Inline.
				type: ("Inline" | "ValueRef") & ("Inline" | "ValueRef") | *"Inline"

				// ValueRef contains the contents of the body
				// specified as a local object reference.
				// Only a reference to ConfigMap is supported.
				//
				// The value of key `response.body` in the ConfigMap will be used
				// as the response body.
				// If the key is not found, the first value in the ConfigMap will
				// be used.
				valueRef?: {
					// Group is the group of the referent. For example,
					// "gateway.networking.k8s.io".
					// When unspecified or empty string, core API group is inferred.
					group: strings.MaxRunes(253) & {
						=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
					}

					// Kind is kind of the referent. For example "HTTPRoute" or
					// "Service".
					kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
						=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
					}

					// Name is the name of the referent.
					name: strings.MaxRunes(253) & strings.MinRunes(1)
				}
			}

			// Content Type of the response. This will be set in the
			// Content-Type header.
			contentType?: string

			// Status Code of the Custom Response
			// If unset, does not override the status of response.
			statusCode?: int
		}
	}]

	// Retry provides more advanced usage, allowing users to customize
	// the number of retries, retry fallback strategy, and retry
	// triggering conditions.
	// If not set, retry will be disabled.
	retry?: {
		// NumAttemptsPerPriority defines the number of requests (initial
		// attempt + retries)
		// that should be sent to the same priority before switching to a
		// different one.
		// If not specified or set to 0, all requests are sent to the
		// highest priority that is healthy.
		numAttemptsPerPriority?: int

		// NumRetries is the number of retries to be attempted. Defaults
		// to 2.
		numRetries?: int & >=0 | *2

		// PerRetry is the retry policy to be applied per retry attempt.
		perRetry?: {
			// Backoff is the backoff policy to be applied per retry attempt.
			// gateway uses a fully jittered exponential
			// back-off algorithm for retries. For additional details,
			// see
			// https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
			backOff?: {
				// BaseInterval is the base interval between retries.
				baseInterval?: string

				// MaxInterval is the maximum interval between retries. This
				// parameter is optional, but must be greater than or equal to
				// the base_interval if set.
				// The default is 10 times the base_interval
				maxInterval?: string
			}

			// Timeout is the timeout per retry attempt.
			timeout?: string
		}

		// RetryOn specifies the retry trigger condition.
		//
		// If not specified, the default is to retry on
		// connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
		retryOn?: {
			// HttpStatusCodes specifies the http status codes to be retried.
			// The retriable-status-codes trigger must also be configured for
			// these status codes to trigger a retry.
			httpStatusCodes?: [...int & <600 & >=100]

			// Triggers specifies the retry trigger condition(Http/Grpc).
			triggers?: [..."5xx" | "gateway-error" | "reset" | "connect-failure" | "retriable-4xx" | "refused-stream" | "retriable-status-codes" | "cancelled" | "deadline-exceeded" | "internal" | "resource-exhausted" | "unavailable"]
		}
	}

	// TargetRef is the name of the resource this policy is being
	// attached to.
	// This policy and the TargetRef MUST be in the same namespace for
	// this
	// Policy to have effect
	//
	// Deprecated: use targetRefs/targetSelectors instead
	targetRef?: {
		// Group is the group of the target resource.
		group: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}

	// TargetRefs are the names of the Gateway resources this policy
	// is being attached to.
	targetRefs?: [...{
		// Group is the group of the target resource.
		group: strings.MaxRunes(253) & {
			=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}

		// Kind is kind of the target resource.
		kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// Name is the name of the target resource.
		name: strings.MaxRunes(253) & strings.MinRunes(1)

		// SectionName is the name of a section within the target
		// resource. When
		// unspecified, this targetRef targets the entire resource. In the
		// following
		// resources, SectionName is interpreted as the following:
		//
		// * Gateway: Listener name
		// * HTTPRoute: HTTPRouteRule name
		// * Service: Port name
		//
		// If a SectionName is specified, but does not exist on the
		// targeted object,
		// the Policy must fail to attach, and the policy implementation
		// should record
		// a `ResolvedRefs` or similar Condition in the Policy's status.
		sectionName?: strings.MaxRunes(253) & strings.MinRunes(1) & {
			=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
		}
	}]

	// TargetSelectors allow targeting resources for this policy based
	// on labels
	targetSelectors?: [...{
		// Group is the group that this selector targets. Defaults to
		// gateway.networking.k8s.io
		group?: strings.MaxRunes(253) & =~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$" | *"gateway.networking.k8s.io"

		// Kind is the resource kind that this selector targets.
		kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
			=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
		}

		// MatchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator: string

			// values is an array of string values. If the operator is In or
			// NotIn,
			// the values array must be non-empty. If the operator is Exists
			// or DoesNotExist,
			// the values array must be empty. This array is replaced during a
			// strategic
			// merge patch.
			values?: [...string]
		}]

		// MatchLabels are the set of label selectors for identifying the
		// targeted resource
		matchLabels?: {
			[string]: string
		}
	}]

	// TcpKeepalive settings associated with the upstream client
	// connection.
	// Disabled by default.
	tcpKeepalive?: {
		// The duration a connection needs to be idle before keep-alive
		// probes start being sent.
		// The duration format is
		// Defaults to `7200s`.
		idleTime?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// The duration between keep-alive probes.
		// Defaults to `75s`.
		interval?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

		// The total number of unacknowledged probes to send before
		// deciding
		// the connection is dead.
		// Defaults to 9.
		probes?: int
	}
	telemetry?: {
		// Tracing configures the tracing settings for the backend or
		// HTTPRoute.
		tracing?: {
			// CustomTags defines the custom tags to add to each span.
			// If provider is kubernetes, pod name and namespace are added by
			// default.
			customTags?: {
				[string]: {
					// Environment adds value from environment variable to each span.
					// It's required when the type is "Environment".
					environment?: {
						// DefaultValue defines the default value to use if the
						// environment variable is not set.
						defaultValue?: string

						// Name defines the name of the environment variable which to
						// extract the value from.
						name: string
					}
					literal?: {
						// Value defines the hard-coded value to add to each span.
						value: string
					}

					// RequestHeader adds value from request header to each span.
					// It's required when the type is "RequestHeader".
					requestHeader?: {
						// DefaultValue defines the default value to use if the request
						// header is not set.
						defaultValue?: string

						// Name defines the name of the request header which to extract
						// the value from.
						name: string
					}

					// Type defines the type of custom tag.
					type: "Literal" | "Environment" | "RequestHeader" | *"Literal"
				}
			}

			// SamplingFraction represents the fraction of requests that
			// should be
			// selected for tracing if no prior sampling decision has been
			// made.
			//
			// This will take precedence over sampling fraction on EnvoyProxy
			// if set.
			samplingFraction?: {
				denominator?: int & >=1 | *100
				numerator:    >=0 & int
			}
		}
	}

	// Timeout settings for the backend connections.
	timeout?: {
		// Timeout settings for HTTP.
		http?: {
			// The idle timeout for an HTTP connection. Idle time is defined
			// as a period in which there are no active requests in the
			// connection.
			// Default: 1 hour.
			connectionIdleTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

			// The maximum duration of an HTTP connection.
			// Default: unlimited.
			maxConnectionDuration?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"

			// RequestTimeout is the time until which entire response is
			// received from the upstream.
			requestTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
		}
		tcp?: {
			// The timeout for network connection establishment, including TCP
			// and TLS handshakes.
			// Default: 10 seconds.
			connectTimeout?: =~"^([0-9]{1,5}(h|m|s|ms)){1,4}$"
		}
	}

	// UseClientProtocol configures Envoy to prefer sending requests
	// to backends using
	// the same HTTP protocol that the incoming request used. Defaults
	// to false, which means
	// that Envoy will use the protocol indicated by the attached
	// BackendRef.
	useClientProtocol?: bool
}
