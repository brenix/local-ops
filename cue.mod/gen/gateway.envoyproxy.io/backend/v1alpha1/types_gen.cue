// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f /tmp/crds.yaml

package v1alpha1

import (
	"strings"
	"list"
)

// Backend allows the user to configure the endpoints of a backend
// and
// the behavior of the connection from Envoy Proxy to the backend.
#Backend: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "gateway.envoyproxy.io/v1alpha1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "Backend"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Spec defines the desired state of Backend.
	spec!: #BackendSpec
}

// Spec defines the desired state of Backend.
#BackendSpec: {
	// AppProtocols defines the application protocols to be supported
	// when connecting to the backend.
	appProtocols?: [..."gateway.envoyproxy.io/h2c" | "gateway.envoyproxy.io/ws" | "gateway.envoyproxy.io/wss"]

	// Endpoints defines the endpoints to be used when connecting to
	// the backend.
	endpoints?: list.MaxItems(64) & [...{
		// FQDN defines a FQDN endpoint
		fqdn?: {
			// Hostname defines the FQDN hostname of the backend endpoint.
			hostname: strings.MaxRunes(253) & strings.MinRunes(1) & {
				=~"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}

			// Port defines the port of the backend endpoint.
			port: uint16
		}

		// IP defines an IP endpoint. Supports both IPv4 and IPv6
		// addresses.
		ip?: {
			// Address defines the IP address of the backend endpoint.
			// Supports both IPv4 and IPv6 addresses.
			address: strings.MaxRunes(45) & strings.MinRunes(3) & {
				=~"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|^(([0-9a-fA-F]{1,4}:){1,7}[0-9a-fA-F]{1,4}|::|(([0-9a-fA-F]{1,4}:){0,5})?(:[0-9a-fA-F]{1,4}){1,2})$"
			}

			// Port defines the port of the backend endpoint.
			port: uint16
		}
		unix?: {
			// Path defines the unix domain socket path of the backend
			// endpoint.
			// The path length must not exceed 108 characters.
			path: string
		}

		// Zone defines the service zone of the backend endpoint.
		zone?: string
	}] & [_, ...]

	// Fallback indicates whether the backend is designated as a
	// fallback.
	// It is highly recommended to configure active or passive health
	// checks to ensure that failover can be detected
	// when the active backends become unhealthy and to automatically
	// readjust once the primary backends are healthy again.
	// The overprovisioning factor is set to 1.4, meaning the fallback
	// backends will only start receiving traffic when
	// the health of the active backends falls below 72%.
	fallback?: bool

	// TLS defines the TLS settings for the backend.
	// TLS.CACertificateRefs and TLS.WellKnownCACertificates can only
	// be specified for DynamicResolver backends.
	// TLS.InsecureSkipVerify can be specified for any Backends
	tls?: {
		// CACertificateRefs contains one or more references to Kubernetes
		// objects that
		// contain TLS certificates of the Certificate Authorities that
		// can be used
		// as a trust anchor to validate the certificates presented by the
		// backend.
		//
		// A single reference to a Kubernetes ConfigMap or a Kubernetes
		// Secret,
		// with the CA certificate in a key named `ca.crt` is currently
		// supported.
		//
		// If CACertificateRefs is empty or unspecified, then
		// WellKnownCACertificates must be
		// specified. Only one of CACertificateRefs or
		// WellKnownCACertificates may be specified,
		// not both.
		//
		// Only used for DynamicResolver backends.
		caCertificateRefs?: list.MaxItems(8) & [...{
			// Group is the group of the referent. For example,
			// "gateway.networking.k8s.io".
			// When unspecified or empty string, core API group is inferred.
			group: strings.MaxRunes(253) & {
				=~"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"
			}

			// Kind is kind of the referent. For example "HTTPRoute" or
			// "Service".
			kind: strings.MaxRunes(63) & strings.MinRunes(1) & {
				=~"^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$"
			}

			// Name is the name of the referent.
			name: strings.MaxRunes(253) & strings.MinRunes(1)
		}]

		// InsecureSkipVerify indicates whether the upstream's certificate
		// verification
		// should be skipped. Defaults to "false".
		insecureSkipVerify?: bool | *false

		// WellKnownCACertificates specifies whether system CA
		// certificates may be used in
		// the TLS handshake between the gateway and backend pod.
		//
		// If WellKnownCACertificates is unspecified or empty (""), then
		// CACertificateRefs
		// must be specified with at least one entry for a valid
		// configuration. Only one of
		// CACertificateRefs or WellKnownCACertificates may be specified,
		// not both.
		//
		// Only used for DynamicResolver backends.
		wellKnownCACertificates?: "System"
	}

	// Type defines the type of the backend. Defaults to "Endpoints"
	type?: "Endpoints" | "DynamicResolver" | *"Endpoints"
}
