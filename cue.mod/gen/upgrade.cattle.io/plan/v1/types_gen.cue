// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f /tmp/plans.yaml

package v1

import "strings"

// Plan represents a set of Jobs to apply an upgrade (or other
// operation) to set of Nodes.
#Plan: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "upgrade.cattle.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "Plan"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// PlanSpec represents the user-configurable details of a Plan.
	spec!: #PlanSpec
}

// PlanSpec represents the user-configurable details of a Plan.
#PlanSpec: {
	// A URL that returns HTTP 302 with the last path element of the
	// value returned in the Location header assumed to be an image
	// tag (after munging "+" to "-").
	channel?: string

	// The maximum number of concurrent nodes to apply this update on.
	concurrency?: int64

	// If Cordon is true, the node is cordoned before the upgrade
	// container is run.
	// If drain is specified, the value for cordon is ignored, and the
	// node is cordoned.
	// If neither drain nor cordon are specified and the node is
	// marked as schedulable=false it will not be marked as
	// schedulable=true when the Job completes.
	cordon?: bool

	// Configuration for draining nodes prior to upgrade. If left
	// unspecified, no drain will be performed.
	drain?: {
		deleteEmptydirData?: bool
		deleteLocalData?:    bool
		disableEviction?:    bool
		force?:              bool
		gracePeriod?:        int32
		ignoreDaemonSets?:   bool

		// A label selector is a label query over a set of resources. The
		// result of matchLabels and
		// matchExpressions are ANDed. An empty label selector matches all
		// objects. A null
		// label selector matches no objects.
		podSelector?: {
			// matchExpressions is a list of label selector requirements. The
			// requirements are ANDed.
			matchExpressions?: [...{
				// key is the label key that the selector applies to.
				key!: string

				// operator represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists and DoesNotExist.
				operator!: string

				// values is an array of string values. If the operator is In or
				// NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. This array is replaced during a
				// strategic
				// merge patch.
				values?: [...string]
			}]

			// matchLabels is a map of {key,value} pairs. A single {key,value}
			// in the matchLabels
			// map is equivalent to an element of matchExpressions, whose key
			// field is "key", the
			// operator is "In", and the values array contains only "value".
			// The requirements are ANDed.
			matchLabels?: {
				[string]: string
			}
		}
		skipWaitForDeleteTimeout?: int

		// A Duration represents the elapsed time between two instants
		// as an int64 nanosecond count. The representation limits the
		// largest representable duration to approximately 290 years.
		timeout?: int64
	}

	// Jobs for exclusive plans cannot be run alongside any other
	// exclusive plan.
	exclusive?: bool

	// Image Pull Secrets, used to pull images for the Job.
	imagePullSecrets?: [...{
		// Name of the referent.
		// This field is effectively required, but due to backwards
		// compatibility is
		// allowed to be empty. Instances of this type with an empty value
		// here are
		// almost certainly wrong.
		// More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name?: string
	}]

	// Sets ActiveDeadlineSeconds on Jobs generated to apply this
	// Plan.
	// If the Job does not complete within this time, the Plan will
	// stop processing until it is updated to trigger a redeploy.
	// If set to 0, Jobs have no deadline. If not set, the controller
	// default value is used.
	jobActiveDeadlineSecs?: int64

	// Select which nodes this plan can be applied to.
	nodeSelector?: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key!: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator!: string

			// values is an array of string values. If the operator is In or
			// NotIn,
			// the values array must be non-empty. If the operator is Exists
			// or DoesNotExist,
			// the values array must be empty. This array is replaced during a
			// strategic
			// merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels
		// map is equivalent to an element of matchExpressions, whose key
		// field is "key", the
		// operator is "In", and the values array contains only "value".
		// The requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// Time after a Job for one Node is complete before a new Job will
	// be created for the next Node.
	postCompleteDelay?: string

	// The prepare init container, if specified, is run before
	// cordon/drain which is run before the upgrade container.
	prepare?: {
		args?: [...string]
		command?: [...string]
		envFrom?: [...{
			// The ConfigMap to select from
			configMapRef?: {
				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the ConfigMap must be defined
				optional?: bool
			}

			// Optional text to prepend to the name of each environment
			// variable. Must be a C_IDENTIFIER.
			prefix?: string

			// The Secret to select from
			secretRef?: {
				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret must be defined
				optional?: bool
			}
		}]
		envs?: [...{
			// Name of the environment variable. Must be a C_IDENTIFIER.
			name!: string

			// Variable references $(VAR_NAME) are expanded
			// using the previously defined environment variables in the
			// container and
			// any service environment variables. If a variable cannot be
			// resolved,
			// the reference in the input string will be unchanged. Double $$
			// are reduced
			// to a single $, which allows for escaping the $(VAR_NAME)
			// syntax: i.e.
			// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
			// Escaped references will never be expanded, regardless of
			// whether the variable
			// exists or not.
			// Defaults to "".
			value?: string

			// Source for the environment variable's value. Cannot be used if
			// value is not empty.
			valueFrom?: {
				// Selects a key of a ConfigMap.
				configMapKeyRef?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Selects a field of the pod: supports metadata.name,
				// metadata.namespace, `metadata.labels['<KEY>']`,
				// `metadata.annotations['<KEY>']`,
				// spec.nodeName, spec.serviceAccountName, status.hostIP,
				// status.podIP, status.podIPs.
				fieldRef?: {
					// Version of the schema the FieldPath is written in terms of,
					// defaults to "v1".
					apiVersion?: string

					// Path of the field to select in the specified API version.
					fieldPath!: string
				}

				// Selects a resource of the container: only resources limits and
				// requests
				// (limits.cpu, limits.memory, limits.ephemeral-storage,
				// requests.cpu, requests.memory and requests.ephemeral-storage)
				// are currently supported.
				resourceFieldRef?: {
					// Container name: required for volumes, optional for env vars
					containerName?: string

					// Specifies the output format of the exposed resources, defaults
					// to "1"
					divisor?: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")

					// Required: resource to select
					resource!: string
				}

				// Selects a key of a secret in the pod's namespace
				secretKeyRef?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}
		}]

		// Image name. If the tag is omitted, the value from
		// .status.latestVersion will be used.
		image!: string

		// SecurityContext holds security configuration that will be
		// applied to a container.
		// Some fields are present in both SecurityContext and
		// PodSecurityContext. When both
		// are set, the values in SecurityContext take precedence.
		securityContext?: {
			// AllowPrivilegeEscalation controls whether a process can gain
			// more
			// privileges than its parent process. This bool directly controls
			// if
			// the no_new_privs flag will be set on the container process.
			// AllowPrivilegeEscalation is true always when the container is:
			// 1) run as Privileged
			// 2) has CAP_SYS_ADMIN
			// Note that this field cannot be set when spec.os.name is
			// windows.
			allowPrivilegeEscalation?: bool

			// appArmorProfile is the AppArmor options to use by this
			// container. If set, this profile
			// overrides the pod's appArmorProfile.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			appArmorProfile?: {
				// localhostProfile indicates a profile loaded on the node that
				// should be used.
				// The profile must be preconfigured on the node to work.
				// Must match the loaded name of the profile.
				// Must be set if and only if type is "Localhost".
				localhostProfile?: string

				// type indicates which kind of AppArmor profile will be applied.
				// Valid options are:
				// Localhost - a profile pre-loaded on the node.
				// RuntimeDefault - the container runtime's default profile.
				// Unconfined - no AppArmor enforcement.
				type!: string
			}

			// The capabilities to add/drop when running containers.
			// Defaults to the default set of capabilities granted by the
			// container runtime.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			capabilities?: {
				// Added capabilities
				add?: [...string]

				// Removed capabilities
				drop?: [...string]
			}

			// Run container in privileged mode.
			// Processes in privileged containers are essentially equivalent
			// to root on the host.
			// Defaults to false.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			privileged?: bool

			// procMount denotes the type of proc mount to use for the
			// containers.
			// The default value is Default which uses the container runtime
			// defaults for
			// readonly paths and masked paths.
			// This requires the ProcMountType feature flag to be enabled.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			procMount?: string

			// Whether this container has a read-only root filesystem.
			// Default is false.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			readOnlyRootFilesystem?: bool

			// The GID to run the entrypoint of the container process.
			// Uses runtime default if unset.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			runAsGroup?: int64

			// Indicates that the container must run as a non-root user.
			// If true, the Kubelet will validate the image at runtime to
			// ensure that it
			// does not run as UID 0 (root) and fail to start the container if
			// it does.
			// If unset or false, no such validation will be performed.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			runAsNonRoot?: bool

			// The UID to run the entrypoint of the container process.
			// Defaults to user specified in image metadata if unspecified.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			runAsUser?: int64

			// The SELinux context to be applied to the container.
			// If unspecified, the container runtime will allocate a random
			// SELinux context for each
			// container. May also be set in PodSecurityContext. If set in
			// both SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			seLinuxOptions?: {
				// Level is SELinux level label that applies to the container.
				level?: string

				// Role is a SELinux role label that applies to the container.
				role?: string

				// Type is a SELinux type label that applies to the container.
				type?: string

				// User is a SELinux user label that applies to the container.
				user?: string
			}

			// The seccomp options to use by this container. If seccomp
			// options are
			// provided at both the pod & container level, the container
			// options
			// override the pod options.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			seccompProfile?: {
				// localhostProfile indicates a profile defined in a file on the
				// node should be used.
				// The profile must be preconfigured on the node to work.
				// Must be a descending path, relative to the kubelet's configured
				// seccomp profile location.
				// Must be set if type is "Localhost". Must NOT be set for any
				// other type.
				localhostProfile?: string

				// type indicates which kind of seccomp profile will be applied.
				// Valid options are:
				//
				// Localhost - a profile defined in a file on the node should be
				// used.
				// RuntimeDefault - the container runtime default profile should
				// be used.
				// Unconfined - no profile should be applied.
				type!: string
			}

			// The Windows specific settings applied to all containers.
			// If unspecified, the options from the PodSecurityContext will be
			// used.
			// If set in both SecurityContext and PodSecurityContext, the
			// value specified in SecurityContext takes precedence.
			// Note that this field cannot be set when spec.os.name is linux.
			windowsOptions?: {
				// GMSACredentialSpec is where the GMSA admission webhook
				// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
				// contents of the
				// GMSA credential spec named by the GMSACredentialSpecName field.
				gmsaCredentialSpec?: string

				// GMSACredentialSpecName is the name of the GMSA credential spec
				// to use.
				gmsaCredentialSpecName?: string

				// HostProcess determines if a container should be run as a 'Host
				// Process' container.
				// All of a Pod's containers must have the same effective
				// HostProcess value
				// (it is not allowed to have a mix of HostProcess containers and
				// non-HostProcess containers).
				// In addition, if HostProcess is true then HostNetwork must also
				// be set to true.
				hostProcess?: bool

				// The UserName in Windows to run the entrypoint of the container
				// process.
				// Defaults to the user specified in image metadata if
				// unspecified.
				// May also be set in PodSecurityContext. If set in both
				// SecurityContext and
				// PodSecurityContext, the value specified in SecurityContext
				// takes precedence.
				runAsUserName?: string
			}
		}
		volumes?: [...{
			// Path to mount the Volume at within the Pod.
			destination!: string

			// Name of the Volume as it will appear within the Pod spec.
			name!: string

			// Path on the host to mount.
			source!: string
		}]
	}

	// Priority Class Name of Job, if specified.
	priorityClassName?: string

	// Secrets to be mounted into the Job Pod.
	secrets?: [...{
		// Mode to mount the Secret volume with.
		defaultMode?: int32

		// If set to true, the Secret contents will not be hashed, and
		// changes to the Secret will not trigger new application of the
		// Plan.
		ignoreUpdates?: bool

		// Secret name
		name!: string

		// Path to mount the Secret volume within the Pod.
		path!: string
	}]

	// The service account for the pod to use. As with normal pods, if
	// not specified the default service account from the namespace
	// will be assigned.
	serviceAccountName?: string

	// Specify which node taints should be tolerated by pods applying
	// the upgrade.
	// Anything specified here is appended to the default of:
	// - `{key: node.kubernetes.io/unschedulable, effect: NoSchedule,
	// operator: Exists}`
	tolerations?: [...{
		// Effect indicates the taint effect to match. Empty means match
		// all taint effects.
		// When specified, allowed values are NoSchedule, PreferNoSchedule
		// and NoExecute.
		effect?: string

		// Key is the taint key that the toleration applies to. Empty
		// means match all taint keys.
		// If the key is empty, operator must be Exists; this combination
		// means to match all values and all keys.
		key?: string

		// Operator represents a key's relationship to the value.
		// Valid operators are Exists and Equal. Defaults to Equal.
		// Exists is equivalent to wildcard for value, so that a pod can
		// tolerate all taints of a particular category.
		operator?: string

		// TolerationSeconds represents the period of time the toleration
		// (which must be
		// of effect NoExecute, otherwise this field is ignored) tolerates
		// the taint. By default,
		// it is not set, which means tolerate the taint forever (do not
		// evict). Zero and
		// negative values will be treated as 0 (evict immediately) by the
		// system.
		tolerationSeconds?: int64

		// Value is the taint value the toleration matches to.
		// If the operator is Exists, the value should be empty, otherwise
		// just a regular string.
		value?: string
	}]

	// The upgrade container; must be specified.
	upgrade!: {
		args?: [...string]
		command?: [...string]
		envFrom?: [...{
			// The ConfigMap to select from
			configMapRef?: {
				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the ConfigMap must be defined
				optional?: bool
			}

			// Optional text to prepend to the name of each environment
			// variable. Must be a C_IDENTIFIER.
			prefix?: string

			// The Secret to select from
			secretRef?: {
				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret must be defined
				optional?: bool
			}
		}]
		envs?: [...{
			// Name of the environment variable. Must be a C_IDENTIFIER.
			name!: string

			// Variable references $(VAR_NAME) are expanded
			// using the previously defined environment variables in the
			// container and
			// any service environment variables. If a variable cannot be
			// resolved,
			// the reference in the input string will be unchanged. Double $$
			// are reduced
			// to a single $, which allows for escaping the $(VAR_NAME)
			// syntax: i.e.
			// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
			// Escaped references will never be expanded, regardless of
			// whether the variable
			// exists or not.
			// Defaults to "".
			value?: string

			// Source for the environment variable's value. Cannot be used if
			// value is not empty.
			valueFrom?: {
				// Selects a key of a ConfigMap.
				configMapKeyRef?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Selects a field of the pod: supports metadata.name,
				// metadata.namespace, `metadata.labels['<KEY>']`,
				// `metadata.annotations['<KEY>']`,
				// spec.nodeName, spec.serviceAccountName, status.hostIP,
				// status.podIP, status.podIPs.
				fieldRef?: {
					// Version of the schema the FieldPath is written in terms of,
					// defaults to "v1".
					apiVersion?: string

					// Path of the field to select in the specified API version.
					fieldPath!: string
				}

				// Selects a resource of the container: only resources limits and
				// requests
				// (limits.cpu, limits.memory, limits.ephemeral-storage,
				// requests.cpu, requests.memory and requests.ephemeral-storage)
				// are currently supported.
				resourceFieldRef?: {
					// Container name: required for volumes, optional for env vars
					containerName?: string

					// Specifies the output format of the exposed resources, defaults
					// to "1"
					divisor?: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")

					// Required: resource to select
					resource!: string
				}

				// Selects a key of a secret in the pod's namespace
				secretKeyRef?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}
		}]

		// Image name. If the tag is omitted, the value from
		// .status.latestVersion will be used.
		image!: string

		// SecurityContext holds security configuration that will be
		// applied to a container.
		// Some fields are present in both SecurityContext and
		// PodSecurityContext. When both
		// are set, the values in SecurityContext take precedence.
		securityContext?: {
			// AllowPrivilegeEscalation controls whether a process can gain
			// more
			// privileges than its parent process. This bool directly controls
			// if
			// the no_new_privs flag will be set on the container process.
			// AllowPrivilegeEscalation is true always when the container is:
			// 1) run as Privileged
			// 2) has CAP_SYS_ADMIN
			// Note that this field cannot be set when spec.os.name is
			// windows.
			allowPrivilegeEscalation?: bool

			// appArmorProfile is the AppArmor options to use by this
			// container. If set, this profile
			// overrides the pod's appArmorProfile.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			appArmorProfile?: {
				// localhostProfile indicates a profile loaded on the node that
				// should be used.
				// The profile must be preconfigured on the node to work.
				// Must match the loaded name of the profile.
				// Must be set if and only if type is "Localhost".
				localhostProfile?: string

				// type indicates which kind of AppArmor profile will be applied.
				// Valid options are:
				// Localhost - a profile pre-loaded on the node.
				// RuntimeDefault - the container runtime's default profile.
				// Unconfined - no AppArmor enforcement.
				type!: string
			}

			// The capabilities to add/drop when running containers.
			// Defaults to the default set of capabilities granted by the
			// container runtime.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			capabilities?: {
				// Added capabilities
				add?: [...string]

				// Removed capabilities
				drop?: [...string]
			}

			// Run container in privileged mode.
			// Processes in privileged containers are essentially equivalent
			// to root on the host.
			// Defaults to false.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			privileged?: bool

			// procMount denotes the type of proc mount to use for the
			// containers.
			// The default value is Default which uses the container runtime
			// defaults for
			// readonly paths and masked paths.
			// This requires the ProcMountType feature flag to be enabled.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			procMount?: string

			// Whether this container has a read-only root filesystem.
			// Default is false.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			readOnlyRootFilesystem?: bool

			// The GID to run the entrypoint of the container process.
			// Uses runtime default if unset.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			runAsGroup?: int64

			// Indicates that the container must run as a non-root user.
			// If true, the Kubelet will validate the image at runtime to
			// ensure that it
			// does not run as UID 0 (root) and fail to start the container if
			// it does.
			// If unset or false, no such validation will be performed.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			runAsNonRoot?: bool

			// The UID to run the entrypoint of the container process.
			// Defaults to user specified in image metadata if unspecified.
			// May also be set in PodSecurityContext. If set in both
			// SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			runAsUser?: int64

			// The SELinux context to be applied to the container.
			// If unspecified, the container runtime will allocate a random
			// SELinux context for each
			// container. May also be set in PodSecurityContext. If set in
			// both SecurityContext and
			// PodSecurityContext, the value specified in SecurityContext
			// takes precedence.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			seLinuxOptions?: {
				// Level is SELinux level label that applies to the container.
				level?: string

				// Role is a SELinux role label that applies to the container.
				role?: string

				// Type is a SELinux type label that applies to the container.
				type?: string

				// User is a SELinux user label that applies to the container.
				user?: string
			}

			// The seccomp options to use by this container. If seccomp
			// options are
			// provided at both the pod & container level, the container
			// options
			// override the pod options.
			// Note that this field cannot be set when spec.os.name is
			// windows.
			seccompProfile?: {
				// localhostProfile indicates a profile defined in a file on the
				// node should be used.
				// The profile must be preconfigured on the node to work.
				// Must be a descending path, relative to the kubelet's configured
				// seccomp profile location.
				// Must be set if type is "Localhost". Must NOT be set for any
				// other type.
				localhostProfile?: string

				// type indicates which kind of seccomp profile will be applied.
				// Valid options are:
				//
				// Localhost - a profile defined in a file on the node should be
				// used.
				// RuntimeDefault - the container runtime default profile should
				// be used.
				// Unconfined - no profile should be applied.
				type!: string
			}

			// The Windows specific settings applied to all containers.
			// If unspecified, the options from the PodSecurityContext will be
			// used.
			// If set in both SecurityContext and PodSecurityContext, the
			// value specified in SecurityContext takes precedence.
			// Note that this field cannot be set when spec.os.name is linux.
			windowsOptions?: {
				// GMSACredentialSpec is where the GMSA admission webhook
				// (https://github.com/kubernetes-sigs/windows-gmsa) inlines the
				// contents of the
				// GMSA credential spec named by the GMSACredentialSpecName field.
				gmsaCredentialSpec?: string

				// GMSACredentialSpecName is the name of the GMSA credential spec
				// to use.
				gmsaCredentialSpecName?: string

				// HostProcess determines if a container should be run as a 'Host
				// Process' container.
				// All of a Pod's containers must have the same effective
				// HostProcess value
				// (it is not allowed to have a mix of HostProcess containers and
				// non-HostProcess containers).
				// In addition, if HostProcess is true then HostNetwork must also
				// be set to true.
				hostProcess?: bool

				// The UserName in Windows to run the entrypoint of the container
				// process.
				// Defaults to the user specified in image metadata if
				// unspecified.
				// May also be set in PodSecurityContext. If set in both
				// SecurityContext and
				// PodSecurityContext, the value specified in SecurityContext
				// takes precedence.
				runAsUserName?: string
			}
		}
		volumes?: [...{
			// Path to mount the Volume at within the Pod.
			destination!: string

			// Name of the Volume as it will appear within the Pod spec.
			name!: string

			// Path on the host to mount.
			source!: string
		}]
	}

	// Providing a value for version will prevent polling/resolution
	// of the channel if specified.
	version?: string

	// A time window in which to execute Jobs for this Plan.
	// Jobs will not be generated outside this time window, but may
	// continue executing into the window once started.
	window?: {
		// Days that this time window is valid for
		days?: [..."0" | "su" | "sun" | "sunday" | "1" | "mo" | "mon" | "monday" | "2" | "tu" | "tue" | "tuesday" | "3" | "we" | "wed" | "wednesday" | "4" | "th" | "thu" | "thursday" | "5" | "fr" | "fri" | "friday" | "6" | "sa" | "sat" | "saturday"] & [_, ...]

		// End of the time window.
		endTime?: string

		// Start of the time window.
		startTime?: string

		// Time zone for the time window; if not specified UTC will be
		// used.
		timeZone?: string
	}
}
